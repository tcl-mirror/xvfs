#include <xvfs-core.h>
#include <unistd.h>
#include <string.h>
#include <tcl.h>
#include <sys/stat.h>

#define XVFS_NAME_LOOKUP_ERROR (-1)
#define XVFS_FILE_BLOCKSIZE 1024

#define MIN(a, b) (((a) < (b)) ? (a) : (b))

typedef enum {
	XVFS_FILE_TYPE_REG,
	XVFS_FILE_TYPE_DIR
} xvfs_file_type_t;

typedef Tcl_WideInt xvfs_size_t;

struct xvfs_file_data {
	const char          *name;
	xvfs_file_type_t    type;
	xvfs_size_t         size;
	union {
		const unsigned char *fileContents;
		const char          **dirChildren;
	} data;
};

<?
	package require xvfs
	xvfs::main $argv
?>
static long xvfs_<?= $::xvfs::fsName ?>_nameToIndex(const char *path) {
	unsigned int pathHash;
	
	if (path == NULL) {
		return(XVFS_NAME_LOOKUP_ERROR);
	}
	
	pathHash = Tcl_ZlibAdler32(0, (const unsigned char *) path, strlen(path));
	switch (pathHash) {
<?
	for {set index 0} {$index < [llength $::xvfs::outputFiles]} {incr index} {
		set outputFile [lindex $::xvfs::outputFiles $index]
		set outputFileHash [zlib adler32 $outputFile 0]
		lappend outputFileHashToIndex($outputFileHash) $index
	}
	
	foreach {outputFileHash outputFileIndexes} [lsort -stride 2 -dictionary [array get outputFileHashToIndex]] {
?>		case <?= $outputFileHash ?>:
<?
			foreach outputFileIndex $outputFileIndexes {
?>			if (strcmp(path, xvfs_<?= $::xvfs::fsName ?>_data[<?= $outputFileIndex ?>].name) == 0) {
				return(<?= $outputFileIndex ?>);
			}
<?
			}
?>			break;
<?	} ?>
	}
	
	return(XVFS_NAME_LOOKUP_ERROR);
}

static const char **xvfs_<?= $::xvfs::fsName ?>_getChildren(const char *path, Tcl_WideInt *count) {
	struct xvfs_file_data *fileInfo;
	long inode;

	/*
	 * Validate input parameters
	 */
	if (count == NULL) {
		return(NULL);
	}
	
	/*
	 * Get the inode from the lookup function
	 */
	inode = xvfs_<?= $::xvfs::fsName ?>_nameToIndex(path);
	if (inode == XVFS_NAME_LOOKUP_ERROR) {
		return(NULL);
	}
	
	fileInfo = &xvfs_<?= $::xvfs::fsName ?>_data[inode];

	/*
	 * Ensure this is a directory
	 */
	if (fileInfo->type != XVFS_FILE_TYPE_DIR) {
		return(NULL);
	}
	
	*count = fileInfo->size;
	return(fileInfo->data.dirChildren);
}

static const unsigned char *xvfs_<?= $::xvfs::fsName ?>_getData(const char *path, Tcl_WideInt start, Tcl_WideInt *length) {
	struct xvfs_file_data *fileInfo;
	Tcl_WideInt resultLength;
	long inode;

	/*
	 * Validate input parameters
	 */
	if (start < 0) {
		return(NULL);
	}
	
	if (length == NULL) {
		return(NULL);
	}
	
	if (*length < 0) {
		return(NULL);
	}
	
	/*
	 * Get the inode from the lookup function
	 */
	inode = xvfs_<?= $::xvfs::fsName ?>_nameToIndex(path);
	if (inode == XVFS_NAME_LOOKUP_ERROR) {
		return(NULL);
	}
	
	fileInfo = &xvfs_<?= $::xvfs::fsName ?>_data[inode];

	/*
	 * Ensure this is a file that can be read
	 */
	if (fileInfo->type != XVFS_FILE_TYPE_REG) {
		return(NULL);
	}

	/*
	 * Validate the length
	 */
	if (start > fileInfo->size) {
		*length = -1;
		return(NULL);
	}

	if (*length == 0) {
		resultLength = fileInfo->size - start;
	} else {
		resultLength = MIN(fileInfo->size - start, *length);
	}
	*length = resultLength;
	
	/*
	 * Return the data
	 */
	return(fileInfo->data.fileContents + start);
}

static int xvfs_<?= $::xvfs::fsName ?>_getInfo(const char *path, Tcl_StatBuf *statBuf) {
	struct xvfs_file_data *fileInfo;
	long inode;

	/*
	 * Validate input parameters
	 */
	if (!statBuf) {
		return(-1);
	}
	
	/*
	 * Get the inode from the lookup function
	 */
	inode = xvfs_<?= $::xvfs::fsName ?>_nameToIndex(path);
	if (inode == XVFS_NAME_LOOKUP_ERROR) {
		return(-1);
	}
	
	fileInfo = &xvfs_<?= $::xvfs::fsName ?>_data[inode];
	
	statBuf->st_dev   = 0;
	statBuf->st_rdev  = 0;
	statBuf->st_ino   = inode;
	statBuf->st_uid   = -1;
	statBuf->st_gid   = -1;
	statBuf->st_atime = 0;
	statBuf->st_ctime = 0;
	statBuf->st_mtime = 0;
	statBuf->st_blksize = XVFS_FILE_BLOCKSIZE;
	
	if (fileInfo->type == XVFS_FILE_TYPE_REG) {
		statBuf->st_mode   = 0400;
		statBuf->st_nlink  = 1;
		statBuf->st_size   = fileInfo->size;
		statBuf->st_blocks = (fileInfo->size + statBuf->st_blksize - 1) / statBuf->st_blksize;
	} else if (fileInfo->type == XVFS_FILE_TYPE_DIR) {
		statBuf->st_mode   = 0500;
		statBuf->st_nlink  = fileInfo->size;
		statBuf->st_size   = fileInfo->size;
		statBuf->st_blocks = 1;
	}
	
	return(0);
}


static struct Xvfs_FSInfo xvfs_<?= $::xvfs::fsName ?>_fsInfo = {
	.protocolVersion = XVFS_PROTOCOL_VERSION,
	.name            = "<?= $::xvfs::fsName ?>",
	.getChildrenProc = xvfs_<?= $::xvfs::fsName ?>_getChildren,
	.getDataProc     = xvfs_<?= $::xvfs::fsName ?>_getData,
	.getInfoProc     = xvfs_<?= $::xvfs::fsName ?>_getInfo
};

int Xvfs_<?= $::xvfs::fsName ?>_Init(Tcl_Interp *interp) {
	int register_ret;

#ifdef USE_TCL_STUBS
	const char *tclInitStubs_ret;
	/* Initialize Stubs */
	tclInitStubs_ret = Tcl_InitStubs(interp, TCL_PATCH_LEVEL, 0);
	if (!tclInitStubs_ret) {
		return(TCL_ERROR);
	}
#endif
	
	register_ret = Xvfs_Register(interp, &xvfs_<?= $::xvfs::fsName ?>_fsInfo);
	if (register_ret != TCL_OK) {
		return(register_ret);
	}
	
	return(TCL_OK);
}